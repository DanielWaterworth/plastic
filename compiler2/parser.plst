import iter
import json

import lex
import ts
import type
import expr
import code_block

enum ServiceDecl
    attr_(String, type.Type) |
    private_ |
    implements_
end

enum TopLevel
    record_ |
    enum_(String, List((String, List(type.Type)))) |
    service_(String, List((String, type.Type)), List(ServiceDecl)) |
    entry_(code_block.Block) |
    function_(String, List((String, type.Type)), type.Type, code_block.Block) |
    coroutine_(String, List((String, type.Type)), type.Type, type.Type, code_block.Block)
end

define parse_imports(tokens : List(lex.Token)) -> (List(String), List(lex.Token)) do
    imports := [] : (List(String));
    do
        if (tokens.length() > 0)
            k := ts.peek_keyword(tokens);
            match (k)
                just_string(k1) do
                    if (k1 == "import")
                        name, tokens := ts.assert_is_lower_name(tokens.drop(1));
                        imports := imports.append(name);
                    else
                        return (imports, tokens);
                    end
                end
                nothing_string do
                    return (imports, tokens);
                end
            end
        end
    while (true)
    throw void;
end

define parse_parameter(tokens : List(lex.Token)) -> (String, type.Type, List(lex.Token)) do
    name, tokens := ts.assert_is_lower_name(tokens);
    tokens := ts.assert_symbol(tokens, ":");
    t, tokens := type.parse_type(tokens);
    return (name, t, tokens);
end

define parse_parameter_list(tokens : List(lex.Token)) -> (List((String, type.Type)), List(lex.Token)) do
    tokens := ts.assert_symbol(tokens, "(");
    parameters := [] : (List((String, type.Type)));
    do
        token := tokens.index(0);
        match (token)
            lower_name(name) do
                name, t, tokens := parse_parameter(tokens);
                parameters := parameters.append((name, t));
            end
            symbol(s) do
                tokens := ts.assert_symbol(tokens, ")");
                return (parameters, tokens);
            end
        end
    while(true)
    throw void;
end

define parse_function(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "define");
    name, tokens := ts.assert_is_lower_name(tokens);
    parameter_list, tokens := parse_parameter_list(tokens);
    tokens := ts.assert_symbol(tokens, "->");
    return_type, tokens := type.parse_type(tokens);
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := code_block.parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (function_(name, parameter_list, return_type, block), tokens);
end

define parse_coroutine(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "coroutine");
    name, tokens := ts.assert_is_lower_name(tokens);
    parameter_list, tokens := parse_parameter_list(tokens);
    receive_type, tokens := type.parse_type(tokens);
    tokens := ts.assert_symbol(tokens, "->");
    yield_type, tokens := type.parse_type(tokens);
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := code_block.parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (coroutine_(name, parameter_list, receive_type, yield_type, block), tokens);
end

define parse_enum(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "enum");
    throw void;
end

define parse_interface(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "interface");
    throw void;
end

define parse_dependency(tokens : List(lex.Token)) -> (String, type.Type, List(lex.Token)) do
    name, tokens := ts.assert_is_lower_name(tokens);
    tokens := ts.assert_symbol(tokens, ":");
    t, tokens := type.parse_type(tokens);
    return (name, t, tokens);
end

define parse_dependencies(tokens : List(lex.Token)) -> (List((String, type.Type)), List(lex.Token)) do
    throw void;
end

define parse_service_decls(tokens : List(lex.Token)) -> (List(ServiceDecl), List(lex.Token)) do
    throw void;
end

define parse_service(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "service");
    name, tokens := ts.assert_is_upper_name(tokens);
    dependencies, tokens := parse_dependencies(tokens);
    decls, tokens := parse_service_decls(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (service_(name, dependencies, decls), tokens);
end

define parse_entry(tokens : List(lex.Token)) -> (TopLevel, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "entry");
    block, tokens := code_block.parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (entry_(block), tokens);
end

define parse(tokens : List(lex.Token)) -> (List(String), List(TopLevel)) do
    imports, tokens := parse_imports(tokens);
    decls := [] : (List(TopLevel));
    do
        if (tokens.length() == 0)
            return (imports, decls);
        end

        token := tokens.index(0);
        match (token)
            keyword(key) do
                if (key == "define")
                    decl, tokens := parse_function(tokens);
                    decls := decls.append(decl);
                elsif (key == "coroutine")
                    decl, tokens := parse_coroutine(tokens);
                    decls := decls.append(decl);
                elsif (key == "enum")
                    decl, tokens := parse_enum(tokens);
                    decls := decls.append(decl);
                elsif (key == "interface")
                    decl, tokens := parse_interface(tokens);
                    decls := decls.append(decl);
                elsif (key == "service")
                    decl, tokens := parse_service(tokens);
                    decls := decls.append(decl);
                elsif (key == "entry")
                    decl, tokens := parse_entry(tokens);
                    decls := decls.append(decl);
                else
                    throw void;
                end
            end
        end
    while (true)
end

service Test(
            f : file.FileOps
        )
    constructor new()
    end

    implements EntryPoint
        define main() -> Bool do
            fd := @f.open("input.plst".encode_utf8(), 0);
            source := @f.read(fd, 4096).decode_utf8();
            if (source.length() == 4096)
                throw void;
            end
            @f.close(fd);
            debug("lexing");
            tokens := lex.lex(source);
            debug("lexed");
            imports, decls := parse(tokens);
            debug(("parsed", decls));
            return true;
        end
    end
end

entry
    f := file.SysFileOps().new();
    return Test(f).new();
end
