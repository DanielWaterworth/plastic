import string
import iter
import file
import parsing.lex
import parsing.parser
import printer

interface ModuleLoader
    load(String, String) -> List((List(String), parsing.parser.Module));
end

define module_eq(a : List(String), b : List(String)) -> Bool do
    if (a.length() != b.length())
        return false;
    end
    for i in iter.zip(iter.l(a), iter.l(b)) do
        x, y := i;
        if (x != y)
            return false;
        end
    end
    return true;
end

define has_module(module : List(String), modules : List((List(String), a))) -> Bool do
    for m in iter.l(modules) do
        m1, m2 := m;
        if (module_eq(m1, module))
            return true;
        end
    end
    return false;
end

define has_any_module(a : List(List(String)), b : List((List(String), a))) -> Bool do
    for module in iter.l(a) do
        if (has_module(module, b))
            return true;
        end
    end
    return false;
end

define remove(module : List(String), modules : List((List(String), a))) -> List((List(String), a)) do
    output := [] : (List((List(String), a)));

    for m in iter.l(modules) do
        name, mod := m;
        if (not module_eq(name, module))
            output := output.append(m);
        end
    end

    return output;
end

service FileModuleLoader(
            f : file.FileOps,
            p : printer.Printer
        )
    constructor new()
    end

    implements ModuleLoader
        define load(dir : String, module : String) -> List((List(String), parsing.parser.Module)) do
            to_load := [[module]];
            loaded := [] : (List((List(String), parsing.parser.Module)));
            do
                to_load, module_name := to_load.pop();
                if (not has_module(module_name, loaded))
                    m := self.load_module(dir, module_name);
                    match (m)
                        module(imports, decls) do
                        end
                    end
                    loaded := loaded.append((module_name, m));
                    to_load := to_load.extend(imports);
                end
            while (to_load.length() > 0)

            for m in iter.l(loaded) do
                name, mod := m;
            end

            ordered := [] : (List((List(String), parsing.parser.Module)));
            do
                added := false;
                for m in iter.l(loaded) do
                    name, mod := m;
                    match (mod)
                        module(imports, decls) do
                        end
                    end

                    if (not has_any_module(imports, loaded))
                        added := true;
                        ordered := ordered.append(m);
                        loaded := remove(name, loaded);
                    end
                end
                if (not added)
                    debug("recursive module imports");
                    throw void;
                end
            while (loaded.length() > 0)

            return ordered;
        end
    end

    private
        define load_module(dir : String, module : List(String)) -> parsing.parser.Module do
            module_name := string.join(module, ".");
            @p.print("loading: " + module_name);
            lib := @f.exists((string.join(["./lib"] + module, "/") + ".plst").encode_utf8());
            if (lib)
                dir := "./lib";
            end
            fd := @f.open((string.join([dir] + module, "/") + ".plst").encode_utf8(), 0);
            source := @f.read(fd, 102400).decode_utf8();
            if (source.length() == 102400)
                debug("too large");
                throw void;
            end
            @f.close(fd);
            tokens := parsing.lex.lex(source);
            return parsing.parser.parse(tokens);
        end
    end
end
