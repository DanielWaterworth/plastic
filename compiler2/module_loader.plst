import iter
import file
import parsing.lex
import parsing.parser
import printer

interface ModuleLoader
    load(String, String) -> List((List(String), parsing.parser.Module));
end

define join(l : List(String), inter : String) -> String do
    if (l.length() == 0)
        return "";
    end

    output := l.index(0);
    for x in iter.l(l.drop(1)) do
        output := output + inter + x;
    end

    return output;
end

define module_eq(a : List(String), b : List(String)) -> Bool do
    if (a.length() != b.length())
        return false;
    end
    for i in iter.zip(iter.l(a), iter.l(b)) do
        x, y := i;
        if (x != y)
            return false;
        end
    end
    return true;
end

define has_module(module : List(String), modules : List((List(String), a))) -> Bool do
    for m in iter.l(modules) do
        m1, m2 := m;
        if (module_eq(m1, module))
            return true;
        end
    end
    return false;
end

service FileModuleLoader(
            f : file.FileOps,
            p : printer.Printer
        )
    constructor new()
    end

    implements ModuleLoader
        define load(dir : String, module : String) -> List((List(String), parsing.parser.Module)) do
            to_load := [[module]];
            loaded := [] : (List((List(String), parsing.parser.Module)));
            do
                to_load, module_name := to_load.pop();
                if (not has_module(module_name, loaded))
                    m := self.load_module(dir, module_name);
                    match (m)
                        module(imports, decls) do
                        end
                    end
                    loaded := loaded.append((module_name, m));
                    to_load := to_load.extend(imports);
                end
            while (to_load.length() > 0)

            return loaded;
        end
    end

    private
        define load_module(dir : String, module : List(String)) -> parsing.parser.Module do
            module_name := join(module, ".");
            @p.print("loading: " + module_name);
            lib := @f.exists((join(["./lib"] + module, "/") + ".plst").encode_utf8());
            if (lib)
                dir := "./lib";
            end
            fd := @f.open((join([dir] + module, "/") + ".plst").encode_utf8(), 0);
            source := @f.read(fd, 102400).decode_utf8();
            if (source.length() == 102400)
                debug("too large");
                throw void;
            end
            @f.close(fd);
            tokens := parsing.lex.lex(source);
            return parsing.parser.parse(tokens);
        end
    end
end
