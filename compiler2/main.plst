import iter
import string
import module_loader
import typing.t_interface
import typing.signature
import typing.type_check
import code_gen.generate
import printer

define rsplit(s : String, c : Char) -> (String, String) do
    unpacked := s.unpack();

    for i in iter.range(s.length()) do
        i := s.length() - i - 1;
        if (unpacked.index(i) == c)
            return (s.take(i), s.drop(i+1));
        end
    end
    throw void;
end

service Main(
            m : module_loader.ModuleLoader,
            p : printer.Printer
        )
    constructor new()
    end

    implements EntryPoint
        define main(args : List(ByteString)) -> Bool do
            if (args.length() < 2)
                debug("expected module");
                throw void;
            end

            filename := args.index(1).decode_utf8();
            filename, ending := rsplit(filename, '.');
            if (ending != "plst")
                debug("expected plst file");
                throw void;
            end
            dir, module := rsplit(filename, '/');

            loaded_modules := @m.load(dir, module);

            module_interfaces1 := [] : (List((List(String), typing.t_interface.ModuleInterface)));
            module_interfaces2 := [] : (List((List(String), typing.type.ModuleSignature)));
            for x in iter.l(loaded_modules) do
                name, mod := x;

                string_name := string.join(name, ".");
                @p.print("creating types: " + string_name);

                mod_int1 := typing.t_interface.construct_module_interface(mod);
                module_interfaces1 := module_interfaces1.append((name, mod_int1));

                @p.print("creating signatures: " + string_name);

                mod_int2 := typing.signature.construct_module_signatures(module_interfaces1, mod);
                module_interfaces2 := module_interfaces2.append((name, mod_int2));

                @p.print("type checking: " + string_name);

                ctx := typing.type.module_context(module_interfaces2, mod_int2);
                mod1 := typing.type_check.type_check_module(ctx, mod);

                @p.print("code gen: " + string_name);

                code_gen.generate.generate_module(mod1);
            end

            return true;
        end
    end
end

entry
    f := file.SysFileOps().new();
    p := printer.SysPrinter().new();
    loader := module_loader.FileModuleLoader(f, p).new();
    return Main(loader, p).new();
end
