import ts
import expr

enum IfTail
    end_ |
    else_(Block) |
    elsif_(expr.Expression, Block, IfTail)
end

enum Clause
    clause(String, List(String), Block)
end

enum Statement
    assignment(List(String), expr.Expression) |
    if_(expr.Expression, Block, IfTail) |
    do_while(Block, expr.Expression) |
    while_(expr.Expression, Block) |
    for_(String, expr.Expression, Block) |
    match_(expr.Expression, List(Clause)) |
    exp_(expr.Expression)
end

enum Terminator
    return_(expr.Expression) |
    throw_(expr.Expression) |
    no_terminator
end

enum Block
    block(List(Statement), Terminator)
end

define parse_if_tail(tokens : List(lex.Token)) -> (IfTail, List(lex.Token)) do
    k, tokens := ts.assert_is_keyword(tokens);
    if (k == "end")
        return (end_(), tokens);
    elsif (k == "else")
        block, tokens := parse_code_block(tokens);
        tokens := ts.assert_keyword(tokens, "end");
        return (else_(block), tokens);
    elsif (k == "elsif")
        tokens := ts.assert_symbol(tokens, "(");
        exp, tokens := expr.parse_expression(tokens);
        tokens := ts.assert_symbol(tokens, ")");
        block, tokens := parse_code_block(tokens);
        tail, tokens := parse_if_tail(tokens);
        return (elsif_(exp, block, tail), tokens);
    end
    throw void;
end

define parse_if(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "if");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    block, tokens := parse_code_block(tokens);
    tail, tokens := parse_if_tail(tokens);
    return (if_(exp, block, tail), tokens);
end

define parse_do_while(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "while");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    return (do_while(block, exp), tokens);
end

define parse_while(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "while");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    block, tokens := parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (while_(exp, block), tokens);
end

define parse_for(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "for");
    name, tokens := ts.assert_is_lower_name(tokens);
    tokens := ts.assert_keyword(tokens, "in");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (for_(name, exp, block), tokens);
end

define parse_match_clauses(tokens : List(lex.Token)) -> (List(Clause), List(lex.Token)) do
    throw void;
end

define parse_match(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "match");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    clauses, tokens := parse_match_clauses(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (match_(exp, clauses), tokens);
end

define parse_return(tokens : List(lex.Token)) -> (Terminator, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "return");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ";");
    return (return_(exp), tokens);
end

define parse_throw(tokens : List(lex.Token)) -> (Terminator, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "throw");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ";");
    return (throw_(exp), tokens);
end

define parse_assignment(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    name, tokens1 := ts.assert_is_lower_name(tokens);
    s, tokens1 := ts.assert_is_symbol(tokens1);
    if (s == ",")
        tokens := tokens1;
        variables := [name];
        do
            name, tokens := ts.assert_is_lower_name(tokens);
            s, tokens := ts.assert_is_symbol(tokens);
            if (s == ",")
            elsif (s == ":=")
                exp, tokens := expr.parse_expression(tokens);
                tokens := ts.assert_symbol(tokens, ";");
                return (assignment([name], exp), tokens);
            else
                throw void;
            end
        while (true)
    elsif (s == ":=")
        tokens := tokens1;
        exp, tokens := expr.parse_expression(tokens);
        tokens := ts.assert_symbol(tokens, ";");
        return (assignment([name], exp), tokens);
    else
        exp, tokens := expr.parse_expression(tokens);
        return (exp_(exp), tokens);
    end
end

define parse_code_block(tokens : List(lex.Token)) -> (Block, List(lex.Token)) do
    statements := [] : (List(Statement));
    do
        k := ts.peek_keyword(tokens);
        match (k)
            just_string(k1) do
                if (k1 == "if")
                    statement, tokens := parse_if(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "do")
                    statement, tokens := parse_do_while(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "while")
                    statement, tokens := parse_while(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "for")
                    statement, tokens := parse_for(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "match")
                    statement, tokens := parse_match(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "return")
                    terminator, tokens := parse_return(tokens);
                    return (block(statements, terminator), tokens);
                elsif (k1 == "throw")
                    terminator, tokens := parse_throw(tokens);
                    return (block(statements, terminator), tokens);
                elsif (k1 == "end")
                    return (block(statements, no_terminator()), tokens);
                elsif (k1 == "else")
                    return (block(statements, no_terminator()), tokens);
                else
                    exp, tokens := expr.parse_expression(tokens);
                    tokens := ts.assert_symbol(tokens, ";");
                    statements := statements.append(exp_(exp));
                end
            end
            nothing_string do
                name := ts.peek_lower_name(tokens);
                match (name)
                    just_string(name1) do
                        statement, tokens := parse_assignment(tokens);
                        statements := statements.append(statement);
                    end
                    nothing_string do
                        exp, tokens := expr.parse_expression(tokens);
                        tokens := ts.assert_symbol(tokens, ";");
                        statements := statements.append(exp_(exp));
                    end
                end
            end
        end
    while (true)
    throw void;
end
