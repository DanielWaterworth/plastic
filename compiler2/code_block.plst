import ts
import expr

enum IfTail
    end_ |
    else_(Block) |
    elsif_(expr.Expression, Block, IfTail)
end

enum Clause
    clause(String, List(String), Block)
end

enum Destructure
    name_destructure(String) |
    property_destructor(String) |
    tuple_destructure(List(Destructure))
end

enum MaybeDestructure
    just_destructure(Destructure) |
    nothing_destructure
end

enum Statement
    assignment(Destructure, expr.Expression) |
    if_(expr.Expression, Block, IfTail) |
    do_while(Block, expr.Expression) |
    for_(String, expr.Expression, Block) |
    match_(expr.Expression, List(Clause)) |
    exp_(expr.Expression)
end

enum Terminator
    return_(expr.Expression) |
    throw_(expr.Expression) |
    no_terminator
end

enum Block
    block(List(Statement), Terminator)
end

define parse_if_tail(tokens : List(lex.Token)) -> (IfTail, List(lex.Token)) do
    k, tokens := ts.assert_is_keyword(tokens);
    if (k == "end")
        return (end_(), tokens);
    elsif (k == "else")
        block, tokens := parse_code_block(tokens);
        tokens := ts.assert_keyword(tokens, "end");
        return (else_(block), tokens);
    elsif (k == "elsif")
        tokens := ts.assert_symbol(tokens, "(");
        exp, tokens := expr.parse_expression(tokens);
        tokens := ts.assert_symbol(tokens, ")");
        block, tokens := parse_code_block(tokens);
        tail, tokens := parse_if_tail(tokens);
        return (elsif_(exp, block, tail), tokens);
    end
    throw void;
end

define parse_if(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "if");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    block, tokens := parse_code_block(tokens);
    tail, tokens := parse_if_tail(tokens);
    return (if_(exp, block, tail), tokens);
end

define parse_do_while(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "while");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    return (do_while(block, exp), tokens);
end

define parse_for(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "for");
    name, tokens := ts.assert_is_lower_name(tokens);
    tokens := ts.assert_keyword(tokens, "in");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_keyword(tokens, "do");
    block, tokens := parse_code_block(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (for_(name, exp, block), tokens);
end

define parse_match_clauses(tokens : List(lex.Token)) -> (List(Clause), List(lex.Token)) do
    throw void;
end

define parse_match(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "match");
    tokens := ts.assert_symbol(tokens, "(");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ")");
    clauses, tokens := parse_match_clauses(tokens);
    tokens := ts.assert_keyword(tokens, "end");
    return (match_(exp, clauses), tokens);
end

define parse_return(tokens : List(lex.Token)) -> (Terminator, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "return");
    s := ts.peek_symbol(tokens);
    match (s)
        just_string(s1) do
            if (s1 == ";")
                return (return_(expr.void_literal()), tokens.drop(1));
            end
        end
        nothing_string do
        end
    end
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ";");
    return (return_(exp), tokens);
end

define parse_throw(tokens : List(lex.Token)) -> (Terminator, List(lex.Token)) do
    tokens := ts.assert_keyword(tokens, "throw");
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ";");
    return (throw_(exp), tokens);
end

define parse_destructure(tokens : List(lex.Token)) -> (MaybeDestructure, List(lex.Token)) do
    name := ts.peek_lower_name(tokens);
    match (name)
        just_string(name1) do
        end
        nothing_string do
            return (nothing_destructure(), tokens);
        end
    end

    s := ts.peek_symbol(tokens.drop(1));
    match (s)
        just_string(s1) do
        end
        nothing_string do
            return (nothing_destructure(), tokens);
        end
    end

    if (s1 == ",")
        tokens := tokens.drop(2);
        variables := [name_destructure(name1)];
        do
            name1, tokens := ts.assert_is_lower_name(tokens);
            variables := variables.append(name_destructure(name1));
            s1, tokens := ts.assert_is_symbol(tokens);
            if (s1 == ",")
            elsif (s1 == ":=")
                return (just_destructure(tuple_destructure(variables)), tokens);
            else
                throw void;
            end
        while (true)
    elsif (s1 == ":=")
        return (just_destructure(name_destructure(name1)), tokens.drop(2));
    else
        return (nothing_destructure(), tokens);
    end
end

define parse_other_statement(tokens : List(lex.Token)) -> (Statement, List(lex.Token)) do
    d, tokens1 := parse_destructure(tokens);
    match (d)
        just_destructure(d1) do
            exp, tokens := expr.parse_expression(tokens1);
            tokens := ts.assert_symbol(tokens, ";");
            return (assignment(d1, exp), tokens);
        end
        nothing_destructure do
        end
    end
    exp, tokens := expr.parse_expression(tokens);
    tokens := ts.assert_symbol(tokens, ";");
    return (exp_(exp), tokens);
end

define parse_code_block(tokens : List(lex.Token)) -> (Block, List(lex.Token)) do
    statements := [] : (List(Statement));
    do
        k := ts.peek_keyword(tokens);
        match (k)
            just_string(k1) do
                if (k1 == "if")
                    statement, tokens := parse_if(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "do")
                    statement, tokens := parse_do_while(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "for")
                    statement, tokens := parse_for(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "match")
                    statement, tokens := parse_match(tokens);
                    statements := statements.append(statement);
                elsif (k1 == "return")
                    terminator, tokens := parse_return(tokens);
                    return (block(statements, terminator), tokens);
                elsif (k1 == "throw")
                    terminator, tokens := parse_throw(tokens);
                    return (block(statements, terminator), tokens);
                elsif (k1 == "while")
                    return (block(statements, no_terminator()), tokens);
                elsif (k1 == "end")
                    return (block(statements, no_terminator()), tokens);
                elsif (k1 == "else")
                    return (block(statements, no_terminator()), tokens);
                elsif (k1 == "elsif")
                    return (block(statements, no_terminator()), tokens);
                else
                    statement, tokens := parse_other_statement(tokens);
                    statements := statements.append(statement);
                end
            end
            nothing_string do
                statement, tokens := parse_other_statement(tokens);
                statements := statements.append(statement);
            end
        end
    while (true)
    throw void;
end
