import iter
import parsing.parser
import typing.type

enum TypeInterface
    enum_interface(UInt) |
    interface_interface(UInt) |
    service_interface
end

enum ModuleInterface
    module_interface(List((String, TypeInterface)))
end

define construct_module_interface(
            mod : parsing.parser.Module
        )
        -> ModuleInterface do
    match(mod)
        module(imports, decls) do
        end
    end

    type_interfaces := [] : (List((String, TypeInterface)));

    for decl in iter.l(decls) do
        match(decl)
            enum_(name, types, constructors) do
                type_interfaces := type_interfaces.append((name, enum_interface(types.length())));
            end
            service_(name, dependencies, service_decls) do
                type_interfaces := type_interfaces.append((name, service_interface()));
            end
            interface_(name, types, signatures) do
                type_interfaces := type_interfaces.append((name, interface_interface(types.length())));
            end
            entry_(block) do
            end
            fun_(f) do
            end
        end
    end

    return module_interface(type_interfaces);
end

define check_type(
            modules : List((List(String), ModuleInterface)),
            current_module : ModuleInterface,
            t : parsing.type.Type
        )
        -> typing.type.TType do
    debug("check type");
end

define construct_interface_signature(
            modules : List((List(String), ModuleInterface)),
            current_module : ModuleInterface,
            types : List(String),
            signatures : List((String, List(parsing.type.Type), parsing.type.Type))
        )
        -> typing.type.InterfaceSignature do
    signatures1 := [] : (List((String, typing.type.FunctionSignature)));
    for signature in iter.l(signatures) do
        name, argument_types, return_type := signature;

        argument_types1 := [] : (List(typing.type.TType));
        for arg in iter.l(argument_types) do
            argument_types1.append(check_type(modules, current_module, arg));
        end

        return_type1 := check_type(modules, current_module, return_type);
    end

    return typing.type.interface_signature(types, signatures1);
end

define construct_module_signatures(
            modules : List((List(String), ModuleInterface)),
            current_module : ModuleInterface,
            mod : parsing.parser.Module
        )
        -> typing.type.ModuleSignature do
    match(mod)
        module(imports, decls) do
        end
    end

    for decl in iter.l(decls) do
        match(decl)
            enum_(name, types, constructors) do
                debug("enum signature");
                throw void;
            end
            service_(name, dependencies, service_decls) do
                debug("service signature");
                throw void;
            end
            interface_(name, types, signatures) do
                construct_interface_signature(modules, current_module, types, signatures);
            end
            entry_(block) do
            end
            fun_(f) do
                debug("function signature");
                throw void;
            end
        end
    end

    throw void;
end
