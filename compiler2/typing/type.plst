import iter
import parsing.type

enum FunctionSignature
    function_signature(List(TType), TType) |
    coroutine_signature(List(TType), TType, TType)
end

enum TypeSignature
    enum_signature(List(String), List((String, List(TType)))) |
    interface_signature(List(String), List((String, FunctionSignature))) |
    service_signature
end

enum ModuleSignature
    module_signature(
        List((String, FunctionSignature)),
        List((String, TypeSignature))
    )
end

enum ModuleContext
    module_context(
        List((List(String), ModuleSignature)),
        ModuleSignature,
        List(String)
    )
end

enum TType
    bool_type |
    uint_type |
    char_type |
    string_type |
    void_type |
    quantified(String) |
    list_type(TType) |
    tuple_type(List(TType)) |
    coroutine_type(TType, TType) |
    instantiation(List(String), String, List(TType))
end

enum MaybeTType
    just_ttype(TType) |
    nothing_ttype
end

enum Context
    context(
        ModuleContext,
        List((String, TType)), # dependencies
        List((String, TType)), # attrs
        List((String, TType)) # variables
    )
end

enum TypeContext
    type_context(
        List((String, TType))
    )
end

define lookup_variable(
            context : Context,
            name: String
        )
        -> TType do
    match (context)
        context(module_context, dependencies, attrs, variables) do
            for x in iter.l(variables) do
                name1, v := x;
                if (name == name1)
                    return v;
                end
            end
        end
    end
end

define empty_type_context() -> TypeContext do
    return type_context([] : (List((String, TType))));
end
