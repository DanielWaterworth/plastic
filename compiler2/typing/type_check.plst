import iter
import parsing.parser
import typing.type
import typing.signature
import typing.code_block

enum TModule
    t_module(List(TTopLevel))
end

enum TFunction
    t_function_(String, List((String, typing.type.TType)), typing.type.TType, typing.code_block.TBlock) |
    t_coroutine_(String, List((String, typing.type.TType)), typing.type.TType, typing.type.TType, typing.code_block.TBlock)
end

enum TServiceDecl
    t_constructor_(String, List((String, typing.type.TType)), typing.code_block.TBlock) |
    t_attr_(String, typing.type.TType) |
    t_private_(List(TFunction)) |
    t_implements_(typing.type.TType, List(TFunction))
end

enum TTopLevel
    t_enum(String, List(String), List((String, List(typing.type.TType)))) |
    t_service(String, List((String, typing.type.TType)), List(TServiceDecl)) |
    t_interface(String, List(String), List((String, List(typing.type.TType), typing.type.TType))) |
    t_entry(typing.code_block.TBlock) |
    t_fun(TFunction)
end

define type_check_function(
            module_context : typing.type.ModuleContext,
            function : parsing.parser.Function
        )
        -> TTopLevel do
    debug("type_check_function");
    throw void;
end

define type_check_entry(
            module_context : typing.type.ModuleContext,
            block : parsing.code_block.Block
        )
        -> TTopLevel do
    debug("type_check_entry");
    throw void;
end

define type_check_service(
            module_context : typing.type.ModuleContext,
            name : String,
            dependencies : List((String, parsing.type.Type)),
            decls : List(parsing.parser.ServiceDecl)
        )
        -> TTopLevel do
    dependencies1 := [] : (List((String, typing.type.TType)));
    for d in iter.l(dependencies) do
        name, t := d;
        ctx := typing.type.empty_type_context();
        ctx, t1 := typing.type.resolve_type(module_context, ctx, t);
        dependencies1 := dependencies1.append((name, t1));
    end

    attrs := [] : (List((String, typing.type.TType)));
    for decl in iter.l(decls) do
        match(decl)
            attr_(name, t) do
                ctx := typing.type.empty_type_context();
                ctx, t1 := typing.type.resolve_type(module_context, ctx, t);
                attrs := attrs.append((name, t1));
            end
            constructor_(name, parameters, block) do
            end
            implements_(interface_, functions) do
            end
            private_(functions) do
            end
        end
    end

    for decl in iter.l(decls) do
        match(decl)
            attr_(name, t) do
            end
            constructor_(name, parameters, block) do
                parameters1 := [] : (List((String, typing.type.TType)));
                for parameter in iter.l(parameters) do
                    name, t := parameter;
                    ctx := typing.type.empty_type_context();
                    ctx, t1 := typing.type.resolve_type(module_context, ctx, t);
                    parameters1 := parameters1.append((name, t1));
                end

                ctx1 :=
                    typing.type.context(
                        module_context,
                        dependencies1,
                        attrs,
                        parameters1
                    );
                typing.code_block.check_block(ctx1, block);
            end
            implements_(interface_, functions) do
                ctx := typing.type.empty_type_context();
                ctx, t_interface := typing.type.resolve_type(module_context, ctx, interface_);
                debug("service implements");
                throw void;
            end
            private_(functions) do
                debug("service private");
                throw void;
            end
        end
    end

    throw void;
end

define type_check_top_level(
            module_context : typing.type.ModuleContext,
            decl : parsing.parser.TopLevel
        )
        -> List(TTopLevel) do
    match (decl)
        enum_(name, types, constructors) do
            return [] : (List(TTopLevel));
        end
        service_(name, dependencies, service_decls) do
            return [type_check_service(module_context, name, dependencies, service_decls)];
        end
        interface_(name, types, signatures) do
            return [] : (List(TTopLevel));
        end
        entry_(block) do
            return [type_check_entry(module_context, block)];
        end
        fun_(f) do
            return [type_check_function(module_context, f)];
        end
    end
end

define type_check_module(
            module_context : typing.type.ModuleContext,
            mod : parsing.parser.Module
        )
        -> TModule do
    match(mod)
        module(imports, decls) do
        end
    end

    output := [] : (List(TTopLevel));
    for decl in iter.l(decls) do
        output := output.extend(type_check_top_level(module_context, decl));
    end

    return t_module(output);
end
